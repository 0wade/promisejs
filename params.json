{"name":"Promisejs","tagline":"Lightweight javascript implementation of promises.","body":"# promise.js\r\n\r\nA lightweight javascript implementation of promises.\r\n\r\n## Using the `Promise` Object\r\n\r\nPromises provide an alternative to callback-passing. Asynchronous functions return a `Promise` object onto which callbacks can be attached.\r\n\r\nCallbacks are attached using the `.then(callback)` method. They will be called when the promise is resolved.\r\n\r\n```js\r\nvar p = asyncfoo(a, b, c);\r\n\r\np.then(function(error, result) {\r\n    if (error) return;\r\n    alert(result);\r\n});\r\n```\r\n\r\nAsynchronous functions must resolve the promise with the `.done()` method when their task is done. This invokes the promise callback(s) with the same arguments that were passed to `.done()`.\r\n\r\n```js\r\nfunction asyncfoo() {\r\n\r\n    var p = new promise.Promise();  /* (1) create a Promise */\r\n\r\n    setTimeout(function() {\r\n        p.done(null, \"O hai!\");     /* (3) resolve it when ready */\r\n    }, 1000);\r\n\r\n    return p;                       /* (2) return it */\r\n}\r\n```\r\n\r\n## A Word on Callback Signatures\r\n\r\nAlthough an arbitrary number of arguments are accepted for callbacks, the following signature is recommended: `callback(error, result)`.\r\n\r\nThe `error` parameter can be used to pass an error code such that `error != false` in case something went wrong; the `result` parameter is used to pass a value produced by the asynchronous task. This allows to write callbacks like this:\r\n\r\n```js\r\nfunction callback(error, result) {\r\n    if (error) {\r\n        /* Deal with error case. */\r\n        ...\r\n        return;\r\n    }\r\n       \r\n    /* Deal with normal case. */\r\n    ...\r\n}\r\n```\r\n\r\n## Chaining Asynchronous Functions\r\n\r\nThere are two ways of chaining asynchronous function calls. The first one is to make the callback return a promise object and to chain `.then()` calls. Indeed, `.then()` returns a `Promise` that is resolved when the callback resolves its promise.\r\n\r\n**Example:**\r\n\r\n```js\r\nfunction late(n) {\r\n    var p = new promise.Promise();\r\n    setTimeout(function() {\r\n        p.done(null, n);\r\n    }, n);\r\n    return p;\r\n}\r\n\r\nlate(100).then(\r\n    function(err, n) {\r\n        return late(n + 200);\r\n    }\r\n).then(\r\n    function(err, n) {\r\n        return late(n + 300);\r\n    }\r\n).then(\r\n    function(err, n) {\r\n        return late(n + 400);\r\n    }\r\n).then(\r\n    function(err, n) {\r\n        alert(n);\r\n    }\r\n);\r\n```\r\n\r\nThe other option is to use `promise.chain()`. The function expects an array of asynchronous functions that return a promise each. `promise.chain()` itself returns a `Promise`.\r\n\r\n```js\r\npromise.chain([f1, f2, f3, ...]);\r\n```\r\n\r\n**Example:**\r\n\r\n```js\r\nfunction late(n) {\r\n    var p = new promise.Promise();\r\n    setTimeout(function() {\r\n        p.done(null, n);\r\n    }, n);\r\n    return p;\r\n}\r\n\r\npromise.chain([\r\n    function() {\r\n        return late(100);\r\n    },\r\n    function(err, n) {\r\n        return late(n + 200);\r\n    },\r\n    function(err, n) {\r\n        return late(n + 300);\r\n    },\r\n    function(err, n) {\r\n        return late(n + 400);\r\n    }\r\n]).then(\r\n    function(err, n) {\r\n        alert(n);\r\n    }\r\n);\r\n```\r\n\r\n## Joining Functions\r\n\r\n    promise.join([p1, p2, p3, ...]);\r\n\r\n`promise.join()` expects an array of `Promise` object and returns a `Promise` that will be resolved once all the arguments have been resolved. The callback will be passed an array containing the values passed by each promise, in the same order that the promises were given. \r\n\r\n**Example**:\r\n\r\n```js\r\nfunction late(n) {\r\n    var p = new promise.Promise();\r\n    setTimeout(function() {\r\n        p.done(null, n);\r\n    }, n);\r\n    return p;\r\n}\r\n\r\npromise.join([\r\n    late(400),\r\n    late(800)\r\n]).then(\r\n    function(results) {\r\n        var res0 = results[0];\r\n        var res1 = results[1];\r\n        alert(res0[1] + \" \" + res1[1]);\r\n    }\r\n);\r\n```\r\n\r\n## AJAX Functions Included\r\n\r\nBecause AJAX requests are the root of much asynchrony in Javascript, promise.js provides the following functions:\r\n\r\n```js\r\npromise.get(url, data, headers)\r\npromise.post(url, data, headers)\r\npromise.put(url, data, headers)\r\npromise.del(url, data, headers)\r\n```\r\n\r\n`data` *(optional)* : a {key: value} object or url-encoded string.\r\n\r\n`headers` *(optional)* :  a {key: value} object (e.g. `{\"Accept\": \"application/json\"}`).\r\n\r\n**Example**:\r\n\r\n```js\r\npromise.get('/').then(function(error, text, xhr) {\r\n    if (error) {\r\n        alert('Error ' + xhr.status);\r\n        return;\r\n    }\r\n    alert('The page contains ' + text.length + ' character(s).');\r\n});\r\n```\r\n\r\nYou can set a time in milliseconds after which unresponsive AJAX\r\nrequests should be aborted. This is a global configuration option,\r\ndisabled by default.\r\n\r\n    /* Global configuration option */\r\n    promise.ajaxTimeout = 10000;\r\n\r\n\r\n## Browser compatibility\r\n\r\nThe library has been successfully tested on IE5.5+ and FF1.5+\r\n\r\n\r\nHave fun!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}